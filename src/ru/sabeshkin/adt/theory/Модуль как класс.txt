Разбираемся с модульным противоречием. Модуль как класс.

1) Существуют ли ситуации, когда связи между модулями должны делаться публичными?

Да, когда мы говорим какие структуры должны поступить в конструктор новой структуры данных. Как именно мы будем использовать это можно не детализировать. 
Хотя можно и объявлять, что подавать надо, например, реализующее интерфейс Iterable, но далее не уточнять как будем использовать.
--
2) Какие метрики вы бы предложили для количественной оценки принципов организации модулей?

Я подсчитал бы то, сколько из принципов соблюдается.
--
3) Если вы разрабатывали программы, в которых было хотя бы 3-5 классов, как бы вы оценили их модульность по этим метрикам?

В целом, разделение логики на структуры было. После чего структуры, которые выделял а отдельные модули, использовал через композицию в других модулях - принцип 5.
Перейдя к модулям, как классам, стало возможным применять в Java принципы 1,2,3,4.

===
Рефлексия по примерам для пяти принципов повторного использования модуля в Java.

Главная ошибка, что все таки думал о классах, по причине описанной в первом пункте, т.к. не думал раньше что такую задачу язык может решать на уровне модуля. 
1. Не знал что можно параметризировать модули, т.к. в других языках с которыми работал тоже такого не видел, поэтому все таки думал о классах. 

2. И 3. Понятно. 

4. Имеется в виду, что модно импортировать не все функции пакета, а только выбранные. 
Например, не java.util.*, а java.util.Strings.
Но при переопределении оставшихся у нас не будет механизма, для того, что бы точно отследить, функции с каким названием есть в модуле, который импортируем. 

5. Действительно, можно мало использовать композицию - has-a.
Я думал именно о наследовании is-a. 