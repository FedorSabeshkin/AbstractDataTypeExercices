Тестировать проще "черный ящик", когда нам просто надо протестировать работу по некоторому интерфейсу, 
нежели прозрачный ящик, когда есть возмодность углубляться в особенности реалиации. 
Для других разработчиков так же стоит предоставлять "плоские классы", когда наследование, как и сама реалиации методов,
скрыта.

// Применим Dependency Injection, для которого задействуем Spring
public class Worker{

// Значение этого поля будет динамически браться из доступного в скопе бина	
	@Autowired
	private List store;

}

@Configuration
public class WorkerConfiguration{

	List list(){
	
		// здесь же можем указать другую реализацию для List, не меняя импорты в основном классе Worker.
		return new ArrayList();
	}
}

==

Рефлексия по решению по принципам организации модулей.

1. Существуют ли ситуации, когда связи между модулями должны делаться публичными? 

Я подумал это о has-a, и применяется регулярно. 
На самом деле, это скорее исключение. 
Я не до конца понял, что значит публичные связи между модулями.
Пока говорят, что это наружение SRP. Возможно потому, что я должен явно заботиться о том, 
что модуль который я планирую использовать в одном кейсе, мне надо так же предусмотрительно снабдить
другим. Хотя это вроде норма. 

2. Какие метрики вы бы предложили для количественной оценки принципов организации модулей?
 
Приведены примеры более наглядно, для уровня понимания начинающего разработчика,
как организовывать модули, и как проверять что это выполненно верно - проверка сколько есть ссылок на выделенный модуль.

3. Существуют ли ситуации, когда связи между модулями должны делаться публичными?

Хороший пример с пиццерией. Сразу понятно что значит выделить семантическую единицу и ее отличие от конкретных классов, которых может быть в проекте
намного больще. Ну и главное из этого: семантческая единица != класс.
В приложении для пиццерий нам достаточно будет выделить: еду, заведение, доставку, а классов делать достаточно много, ориентируясь на эти три основные 
единицы. 
